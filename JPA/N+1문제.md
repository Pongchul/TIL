# JPA N+1 problem

## 1. N+1 문제는 무엇인가

+ 조회 시 1개의 쿼리를 생각하고 설계를 했으나 나오지 않아도 되는 조회의 쿼리가 N개가 더 발생하는 문제이다.
+ DBMS 툴을 이용해 직접 쿼리문을 만들어 조회할 때는 물론 하나의 쿼리가 발생하겠지만 mybatis, 넘어서는 JPA가 등장함에 따라 자동화된 쿼리문들이 생겨나면서 어쩔 수 없이 발생하는 문제.
+ JPA의 경우에는 객체에 대해서 조회한다고 해도 다양한 연관관계들의 매핑에 의해서 관계가 맺어진 다른 객체가 함께 조회되는 경우에 N+1이 발생하게 된다.
+ Ex) 유저 한명이 쓴 게시글들을 조회할 때 유저-게시글을 join한 형태의 쿼리문을 원했지만 N개의 게시글을 또 조회하는 쿼리가 날아가는 경우
---

<br>

## 현재 연관관계 상황


![그림1](https://velog.velcdn.com/images%2Fjinyoungchoi95%2Fpost%2Fc038bce4-0426-4bb9-866f-83513d6c9846%2F1.png)

```java
@Entity
public class User {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false)
  private String name;

  @OneToMany
  private set<Article> articles = emptyset();
}
```
---
```java
@Entity
public class Article {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(length = 50, nullable = false)
  private String title;

  @Lob
  private Content content;

  @ManyToOne
  private User user;

```
+ 한명의 User 여러개의 Article을 가질 수 있는 구조로 가장 흔하게 볼 수 있는 1:N 구조이다. 
+ Fetch type 같은 경우 현재 코드에서는 적용해두지 않았지만 즉시로딩, 지연로딩 각각에 들어가서는 명시하여 사용해야 한다.

<br>

## 즉시로딩


```java
// User.java
@OnetoMany(mappedBy = "user", fetch = FetchType.EAGER)
private Set<Article> articles = emptySet();

// Article.java
@ManyToOne(fetch = FetchType.EAGER)
private User user;
```
+  실무에서 가장 쓰지 말아야 하며, 모든 문제의 첫번째 원인이 되는 즉시로딩
+  User의 입장에서 즉시로딩을 사용한다고 했을 때, Article의 모든 List를 다 같이 조회하고 싶을 상황이 생길 수도 있는데 왜 즉시로딩이 문제가 될까
+  일반적으로 findById에 대한 메소드는 EntityManager에서 PK 값을 찍어서 사용하기 때문에 JPA가 내부적으로 join문을 사용해서 최적화를 다음처럼 진행한다.

```java
@Test
@DisplayName("Eager Type은 User를 단일 조회할 때 join문이 날아간다.)
void userSingleFindTest() {
    System.out.println("== start == ")
    User user = userRepository.findById(1L)
      .orElseThrow(RuntimeException::new);
    System.out.println("== end == ")
    System.out.println(user.name());
}
```
![그림2](https://images.velog.io/images/jinyoungchoi95/post/08483dae-9b7c-46bd-82e0-f457041cb182/2.png)
+ 내부적으로 inner join문 하나가 날아가서 User가 조회됨과 동시에 Article까지 즉시 로딩되는 것을 확인할 수 있다.
+ findById, 즉 EntityManager에서 entityManager.find() 같은 경우 JPA가 내부적으로 JOIN문에 대한 쿼리를 만들어서 반환을 하기 때문에 즉시로딩으로는 문제가 없어보이기도 한다.
+ 문제는 JPQL에서 발생한다. findById만 사용하는 것이 아니라 직접 JPQL문을 짜서 전달하기도 하고, DATA JPA에서 findBy~ 의 쿼리메소드 같은 경우에도 DATA JPA 내부에서 JPQL이 만들어져서 나간다.